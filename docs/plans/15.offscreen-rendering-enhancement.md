# Offscreen Rendering Enhancement for PolychromeText

✅ main goals completed

## 1. Problem Statement & Vision

### Problem
1. Large canvases require scrolling, hiding UI elements and making it unclear when the canvas extends beyond the viewport
2. UI interactions sometimes conflict with canvas painting operations
3. UI elements rendered on the main canvas get exported when saving, creating confusion about layer separation
4. Current inability to work with very large canvases (4000x4000 pixels minimum) due to viewport limitations

### Vision
1. Enable viewing of large canvases on-screen without scrolling
2. Prevent UI interactions from triggering unintended canvas painting
3. Clearly separate UI elements from exportable canvas content
4. Maintain accurate coordinate mapping between scaled on-screen view and full off-screen canvas
5. Support creation of high-resolution artwork (4000x4000 pixels minimum) while maintaining usability

### Primary Technical Challenges
1. Improve UX by eliminating the need to scroll for canvas viewing
2. Improve UX by preventing canvas painting during UI interactions
3. Create a clear system for UI elements that are not exported with the artwork

## 2. Target Users & Use Cases

### Primary Users
- Digital artists creating high-resolution text-based artwork
- Developer/artist (primary user) working on detailed compositions

### Main Goals
- Create high-resolution files while maintaining full visibility of the canvas during the creative process
- Avoid accidental canvas painting during UI interactions
- Work efficiently with large canvases without scrolling or UI conflicts

### Key User Journeys
1. Creating a 900x900 canvas that may be saved as 1800x1800 with high pixel density
2. Working with long horizontal canvases that extend under UI elements
3. Interacting with GUI controls without triggering unintended canvas painting operations
4. Creating high-resolution artwork (4000x4000 pixels minimum) that exceeds typical viewport dimensions

## 3. Core Features & Requirements

### Essential Features (Must-Have) ✅
1. Additional layers in the layers module
2. Dedicated off-screen canvas for full-resolution artwork
3. Dedicated UI canvas (composited down to display canvas) or clear targeting mechanism for on-screen canvas
4. Solution for viewing large canvases without scrolling
5. Prevention of accidental canvas painting during UI interactions
6. Clear separation between UI elements and exportable canvas content

### Nice-to-Have Features - these were added for future awareness and not implemented here
1. Intermediate canvas system for smaller painting areas that can be composited onto the larger off-screen canvas
2. Support for zonal painting with dedicated layers having coordinates, dimensions, rotation, and transparency parameters
3. Enhanced features for the "random history" feature with positioning and rotation capabilities

### Technical Constraints/Requirements
1. Target latest Chrome browser (no cross-browser compatibility requirements)
2. No specific performance requirements beyond proper memory management
3. Memory management considerations for temporary and history canvases

## 4. Success Metrics & Goals

### Measuring Success
- Ability to draw on a smaller on-screen canvas that doesn't require scrolling
- No interference between GUI controls and canvas operations
- Proper saving of artwork at larger sizes than the on-screen display

### Key Performance Indicators
- End-to-end testing coverage for the new feature
- Functional testing of the scaled canvas interaction
- Verification that UI elements don't trigger canvas painting operations

### Timeline
- Target completion: Tomorrow (this week)

## 5. Technical Considerations

### Analysis of Existing Code
After reviewing `sketch.js`, `layers.js`, and `undo/undo.layers.js`, the following key areas for modification have been identified:

*   **`layers.js`:** The `Layers` class currently manages a `drawingLayer` and a `tempLayer`. This class is the perfect place to encapsulate the new layer structure. We will add an `drawingCanvas` for high-resolution drawing and a `uiCanvas` for non-exported UI elements. The existing `drawingLayer` will be repurposed or replaced by the `drawingCanvas`. References to a `displayCanvas` are aliased to the default p5.canvas.
*   **`sketch.js`:** This is the main hub.
    *   The `setup()` function initializes everything. We'll need to change how the canvases are created and managed here.
    *   The `draw()` loop and the `paint()` function are where drawing happens. We need to ensure they draw on the new `drawingCanvas`.
    *   Mouse interaction functions like `standardDraw` need to have their coordinates translated from the on-screen `displayCanvas` to the off-screen `drawingCanvas`.
    *   The `savit()` function needs to be modified to save the high-resolution `drawingCanvas` instead of the visible canvas.
*   **`undo/undo.layers.js`:** The `UndoLayers` class relies on `layers.copy()` to create snapshots. We need to ensure this `copy()` method now targets the `drawingCanvas`. The `show()` method, which restores a previous state, must also draw to the `drawingCanvas`.
*   **`canvas-transforms.js`:** Also needs to be updated to use appropriate layers; analysis incomplete


### Platform Requirements
- Target latest Chrome browser

### Integration Needs
- Primary modules requiring integration: `sketch.js`, `drawing-modes`, `undo/undo.layers.js`.
- Drawing functions already target a passed-in canvas from a layers object, which should simplify integration.

### Scalability & Memory Management
- Ensure proper disposal of temporary canvases.
- Preserve history canvases that are still in use.
- Identify opportunities to minimize memory usage.

## 6. Implementation Approach

Here is a step-by-step plan that reflects the implemented offscreen rendering enhancement.

### Step 1: Refactor `layers.js` for Dynamic Canvas Management

The `Layers` class was significantly enhanced to dynamically manage canvas sizes and scaling. It is now the central authority for creating, resizing, and accessing the different canvases.

*   **Dynamic Resizing**: The `resize()` method is the core of the new implementation. It calculates the `scaleFactor` to fit the artwork on-screen, resizes the main visible p5.js canvas, and recreates the off-screen `drawingCanvas` and `uiCanvas`. It also handles preserving canvas content during operations like rotation.
*   **Canvas Initialization**: The constructor was simplified, and layer creation logic was moved into a private `_createLayer` helper and the `resize` method. `initializeColorMode` was also moved into this class.
*   **Method Updates**: Methods like `copy`, `setFont`, and `textSize` were updated to target the `drawingCanvas` exclusively.

```javascript
// In layers.js
export default class Layers {
  constructor (p5, params, setFont) {
    this.p5 = p5
    this.params = params
    this.setFont = setFont

    this.scaleFactor = 1 // Initial value, will be updated by resize
    this.width = params.width
    this.height = params.height

    // Create initial canvases
    this.resize(this.width, this.height)
  }

  _createLayer (w, h) {
    const layer = this.p5.createGraphics(w, h)
    layer.pixelDensity(this.p5.pixelDensity())
    this.setFont(this.params.font, layer)
    layer.textAlign(this.p5.CENTER, this.p5.CENTER)
    this.initializeColorMode(layer, this.params)
    return layer
  }

  resize (newWidth, newHeight, copyContent = false) {
    this.width = newWidth
    this.height = newHeight

    const maxDisplayWidth = 1025
    const maxDisplayHeight = 650

    const widthRatio = this.width / maxDisplayWidth
    const heightRatio = this.height / maxDisplayHeight

    if (this.width > maxDisplayWidth || this.height > maxDisplayHeight) {
      this.scaleFactor = Math.max(widthRatio, heightRatio)
    } else {
      this.scaleFactor = 1
    }

    const displayWidth = this.width / this.scaleFactor
    const displayHeight = this.height / this.scaleFactor

    // Resize main canvas
    this.p5.resizeCanvas(displayWidth, displayHeight)

    const oldDrawingCanvas = this.drawingCanvas
    const oldUiCanvas = this.uiCanvas

    this.drawingCanvas = this._createLayer(this.width, this.height)
    this.uiCanvas = this.p5.createGraphics(displayWidth, displayHeight)
    this.uiCanvas.pixelDensity(this.p5.pixelDensity())

    if (copyContent && oldDrawingCanvas) {
      this.drawingCanvas.image(oldDrawingCanvas, 0, 0)
    }

    if (oldDrawingCanvas) { oldDrawingCanvas.remove() }
    if (oldUiCanvas) { oldUiCanvas.remove() }
  }

  copy() {
    const layer = this.p5.createGraphics(this.width, this.height)
    layer.pixelDensity(this.p5.pixelDensity())
    layer.image(this.drawingCanvas, 0, 0)
    return layer
  }

  // ... other methods like clone, dispose, setFont, etc.
}
```

### Step 2: Update `sketch.js` to Orchestrate the New Layer System

The main sketch was updated to initialize and use the new `Layers` class.

*   **Setup**: The `p5.setup()` function now initializes the `Layers` class, which handles the creation of all canvases. The main p5 canvas is created to fit the screen, acting as a viewport for the potentially larger off-screen `drawingCanvas`.
*   **Rendering Pipeline**: The `p5.draw()` loop implements the new rendering pipeline:
    1.  A neutral background is drawn on the main (visible) canvas.
    2.  The high-resolution `drawingCanvas` is drawn, scaled down to fit the viewport.
    3.  The `uiCanvas` is drawn on top at a 1:1 scale for UI elements.
    4.  The `uiCanvas` is cleared to prepare for the next frame.
*   **Coordinate Scaling**: Mouse interactions in `standardDraw` now scale the mouse coordinates by the `scaleFactor` to ensure drawing operations are mapped correctly to the high-resolution `drawingCanvas`.
*   **Saving**: The `savit()` function now correctly saves the full-resolution `drawingCanvas`.
*   **Dynamic Resizing**: A `handleResize` function was added to the GUI to allow changing the canvas dimensions on the fly, which leverages the `layers.resize()` method and resets the undo history.

### Step 3: Enhance `undo/undo.layers.js` for Off-screen Canvases and Memory Management

The undo system was adapted to work with the new layer structure and to be more memory-efficient.

*   **Target `drawingCanvas`**: `takeSnapshot` now uses `layers.copy()`, which correctly clones the `drawingCanvas`. The `show()` method, which restores a state, now draws the snapshot back to the `drawingCanvas`.
*   **Memory Management**: A `clear()` method was added to both `UndoLayers` and its internal `ImageCollection`. This method explicitly calls `graphics.remove()` on all stored `p5.Graphics` objects, preventing memory leaks when the undo history is cleared (e.g., after a resize).
*   **Removed `renderFunc`**: The `renderFunc` dependency was removed, as the main `draw()` loop is now solely responsible for rendering.

```javascript
// In undo/undo.layers.js

// ... constructor ...

    this.show = () => {
      // ...
      const image = images.getImage(currentPosition);
      // ...

      // Ensure the restored image is drawn to the offscreen canvas
      layers.drawingCanvas.push();
      layers.drawingCanvas.translate(0, 0);
      layers.drawingCanvas.resetMatrix();
      layers.drawingCanvas.image(image, 0, 0);
      layers.drawingCanvas.pop();
    };

    this.clear = () => {
      currentPosition = -1;
      newestPosition = -1;
      availableStates = 0;
      images.clear(); // This now calls dispose on all stored images
    }
// ...
```

### Step 4: Refactor Canvas Transformation Logic

All canvas transformation functions were updated to work with the new off-screen `drawingCanvas`.

*   **Target `drawingCanvas`**: Functions like `flip`, `mirror`, and `shift` in `canvas-transforms.js` were modified to read from and write to `layers.drawingCanvas`.
*   **Rotation**: The `rotateCanvas` function was significantly improved. Instead of creating a new temporary graphics object, it now leverages `layers.copy()` to save the current state and `layers.resize(newWidth, newHeight, true)` to perform the rotation, preserving the content. This is more efficient and robust.

### Step 5: Update All Other Modules

A project-wide refactoring was performed to ensure all modules correctly interact with the new layer system.

*   **Drawing Modes**: All painters in `src/drawing-modes/` now receive a `layer` object that is the `drawingCanvas` and perform their operations on it.
*   **Color System**: The `color-system.js` was updated to target `layers.drawingCanvas`.
*   **GUI**: All actions, hotkeys, and macros in `src/gui/` that performed drawing operations were updated to use `layers.drawingCanvas` and pass the `layers` object where needed.

### Summary of Changes

1.  **`layers.js`:** Rebuilt into a powerful class that handles dynamic creation, resizing, and scaling of a multi-canvas system (`drawingCanvas`, `uiCanvas`, and the main visible canvas).
2.  **`sketch.js`:** The main application logic was refactored to orchestrate the new layer system, including a new rendering pipeline in `draw()`, coordinate scaling for mouse input, and support for dynamic canvas resizing via the GUI.
3.  **`undo/undo.layers.js`:** Updated to work seamlessly with the `drawingCanvas` and made more memory-safe with a new `clear()` method that properly disposes of stored canvas states.
4.  **`canvas-transforms.js`:** All transformation functions, especially `rotateCanvas`, were rewritten to be compatible with and take advantage of the new `Layers` class methods.
5.  **Project-Wide Refactoring**: All modules that interact with the canvas have been updated from using the old `drawingLayer` to the new `layers.drawingCanvas`, ensuring consistency.


## 7. Testing Strategy

### Functional Testing
1. Verify scaled canvas interaction works correctly
2. Confirm UI elements don't trigger canvas painting operations
3. Test coordinate mapping accuracy between scaled and full-resolution canvases
4. Validate that only off-screen canvas content is saved/exported

### End-to-End Testing
1. Create comprehensive e2e tests for the new feature
2. Test various canvas sizes and scaling scenarios
3. Verify UI interaction isolation from canvas painting

## 8. Risks & Mitigation

### Potential Risks
1. Performance issues with very large canvases
2. Integration challenges with existing systems
3. Coordinate mapping inaccuracies between scaled and full-resolution views

### Mitigation Strategies
1. Implement proper memory management with explicit disposal
2. Thorough testing of integration points
3. Comprehensive coordinate mapping validation

## 9. Dependencies

1. Existing Layers class implementation
2. p5.js graphics library
3. Chrome browser environment
4. Existing drawing modes and undo system
