diff --git a/docs/plans/15.offscreen-rendering-enhancement.md b/docs/plans/15.offscreen-rendering-enhancement.md
index 410d831..0fda1c7 100644
--- a/docs/plans/15.offscreen-rendering-enhancement.md
+++ b/docs/plans/15.offscreen-rendering-enhancement.md
@@ -74,41 +74,333 @@
 
 ## 5. Technical Considerations
 
+### Analysis of Existing Code
+After reviewing `sketch.js`, `layers.js`, and `undo/undo.layers.js`, the following key areas for modification have been identified:
+
+*   **`layers.js`:** The `Layers` class currently manages a `drawingLayer` and a `tempLayer`. This class is the perfect place to encapsulate the new layer structure. We will add an `drawingCanvas` for high-resolution drawing and a `uiCanvas` for non-exported UI elements. The existing `drawingLayer` will be repurposed or replaced by the `drawingCanvas`. References to a `displayCanvas` are aliased to the default p5.canvas.
+*   **`sketch.js`:** This is the main hub.
+    *   The `setup()` function initializes everything. We'll need to change how the canvases are created and managed here.
+    *   The `draw()` loop and the `paint()` function are where drawing happens. We need to ensure they draw on the new `drawingCanvas`.
+    *   Mouse interaction functions like `standardDraw` need to have their coordinates translated from the on-screen `displayCanvas` to the off-screen `drawingCanvas`.
+    *   The `savit()` function needs to be modified to save the high-resolution `drawingCanvas` instead of the visible canvas.
+*   **`undo/undo.layers.js`:** The `UndoLayers` class relies on `layers.copy()` to create snapshots. We need to ensure this `copy()` method now targets the `drawingCanvas`. The `show()` method, which restores a previous state, must also draw to the `drawingCanvas`.
+*   **`canvas-transforms.js`:** Also needs to be updated to use appropriate layers; analysis incomplete
+
+
 ### Platform Requirements
 - Target latest Chrome browser
 
 ### Integration Needs
-- Primary modules requiring integration: sketch.js, drawing-modes, undo-layers
-- Drawing functions already target a passed-in canvas from a layers object, which should simplify integration
-- Intermediate, smaller, custom-coordinate layers may require additional work but are not the primary focus
+- Primary modules requiring integration: `sketch.js`, `drawing-modes`, `undo/undo.layers.js`.
+- Drawing functions already target a passed-in canvas from a layers object, which should simplify integration.
 
 ### Scalability & Memory Management
-- Ensure proper disposal of temporary canvases
-- Preserve history canvases that are still in use
-- Identify opportunities to minimize memory usage
-- Memory management is not a major concern for this implementation but should be handled properly
+- Ensure proper disposal of temporary canvases.
+- Preserve history canvases that are still in use.
+- Identify opportunities to minimize memory usage.
 
 ## 6. Implementation Approach
 
-### Proposed Architecture
-1. Extend the Layers class to include:
-   - Dedicated off-screen canvas (full resolution artwork)
-   - Dedicated UI canvas (separate from drawing operations)
-   - Display canvas (scaled view of off-screen canvas)
-   
-2. Implement coordinate mapping between:
-   - Scaled on-screen coordinates
-   - Full off-screen canvas coordinates
-
-3. Modify rendering pipeline to:
-   - Composite off-screen canvas onto display canvas with scaling
-   - Render UI elements separately on UI canvas
-   - Ensure only off-screen canvas content is saved/exported
-
-### Integration Points
-1. sketch.js - Main integration point for canvas initialization and rendering
-2. drawing-modes - Ensure drawing operations target the correct canvas
-3. undo-layers - Verify compatibility with new layer structure
+Here is a step-by-step plan to implement the offscreen rendering enhancement.
+
+### Step 1: Update `layers.js`
+
+Modify the `Layers` class to manage the new canvas structure.
+
+```javascript
+// In layers.js
+
+export default class Layers {
+  constructor (p5, width, height, scaleFactor) {
+    this.p5 = p5;
+    this.scaleFactor = scaleFactor;
+    this.width = width;
+    this.height = height;
+
+    // The main, high-resolution canvas where all drawing occurs.
+    this.drawingCanvas = p5.createGraphics(width, height);
+    this.drawingCanvas.pixelDensity(p5.pixelDensity());
+
+    // A temporary layer for UI elements, cursors, etc.
+    this.uiCanvas = p5.createGraphics(width / scaleFactor, height / scaleFactor);
+    this.uiCanvas.pixelDensity(p5.pixelDensity());
+
+    // The old drawingLayer is now effectively the drawingCanvas.
+    // The old tempLayer can be repurposed or removed if not needed.
+    this.tempLayer = p5.createGraphics(width, height);
+    this.tempLayer.pixelDensity(p5.pixelDensity());
+  }
+
+  /**
+   * Returns a p5.Graphics object that is a copy of the offscreen canvas.
+   * CALLER OWNS THE RETURNED GRAPHICS - must call dispose() or .remove() when done.
+   * @returns {p5.Graphics} A new graphics object containing a copy of the offscreen canvas.
+   */
+  copy () {
+    const layer = this.p5.createGraphics(this.width, this.height);
+    layer.pixelDensity(this.p5.pixelDensity());
+    layer.image(this.drawingCanvas, 0, 0);
+    return layer;
+  }
+
+  /**
+   * Returns a p5.Graphics object that is a copy of the image passed in.
+   * CALLER OWNS THE RETURNED GRAPHICS - must call dispose() or .remove() when done.
+   * @param {p5.Image|p5.Graphics} img The image to clone
+   * @returns {p5.Graphics} A new graphics object containing a copy of the input image
+   */
+  clone (img) {
+    const g = this.p5.createGraphics(img.width, img.height);
+    g.pixelDensity(this.p5.pixelDensity());
+    g.image(img, 0, 0);
+    return g;
+  }
+
+  /**
+   * Properly dispose of a graphics object created by this layer system.
+   * Safe to call on any p5.Graphics object.
+   * @param {p5.Graphics} graphics The graphics object to dispose
+   */
+  dispose (graphics) {
+    if (graphics?.canvas) {
+      graphics.remove();
+    }
+  }
+
+  /**
+   * Set font for the offscreen canvas.
+   * @param {p5.Font|string} font The font to use for text rendering
+   */
+  setFont (font) {
+    this.drawingCanvas.textFont(font);
+  }
+
+  /**
+   * Set text size for the offscreen canvas.
+   * @param {number} size The size of text in pixels
+   */
+  textSize (size) {
+    this.drawingCanvas.textSize(size);
+  }
+}
+'''
+
+### Step 2: Update `sketch.js`
+
+This involves several changes to the main sketch file. The `p5.createCanvas()` call remains in `setup()` as it is essential for creating the visible on-screen canvas that acts as our viewport. The `Layers` class will handle the creation of the off-screen buffers.
+
+```javascript
+// In sketch.js
+
+// ... imports
+
+export default function Sketch ({ p5Instance: p5, guiControl, textManager, setupCallback }) {
+  const params = allParams;
+  const pct = {};
+
+  const density = 2;
+  let scaleFactor = 1;
+
+  let layers;
+  // ... other variables
+
+  p5.setup = () => {
+    // ... preload logic
+
+    // 1. Define Max On-Screen Dimensions for the visible canvas
+    const maxDisplayWidth = 1025;
+    const maxDisplayHeight = 650;
+
+    // 2. Calculate the scaleFactor dynamically to fit the artwork within the viewport
+    const widthRatio = params.width / maxDisplayWidth;
+    const heightRatio = params.height / maxDisplayHeight;
+
+    if (params.width > maxDisplayWidth || params.height > maxDisplayHeight) {
+      scaleFactor = Math.max(widthRatio, heightRatio);
+    } else {
+      scaleFactor = 1; // Don't scale up if it already fits
+    }
+
+    // 3. Create the main, visible canvas. This is our on-screen viewport.
+    const displayWidth = params.width / scaleFactor;
+    const displayHeight = params.height / scaleFactor;
+    p5.createCanvas(displayWidth, displayHeight);
+    p5.pixelDensity(density);
+
+    // 4. Initialize the Layers class, which creates the off-screen canvases
+    pct.layers = layers = new Layers(p5, params.width, params.height, scaleFactor);
+
+    // ... initialize colorSystem, adjustGamma, canvasTransforms, drawingModes
+    // Pass layers.drawingCanvas to functions that need a drawing surface
+    drawingModes = createDrawingModes({
+      layers: { drawingLayer: layers.drawingCanvas }, // Pass the offscreen canvas
+      colorSystem,
+      hexStringToColors,
+      p5
+    });
+
+    // ... setupGui
+
+    // 5. Update clearCanvas to target the offscreen canvas
+    pct.clearCanvas = ({ layers, params }) => {
+      recordAction({ action: 'clearCanvas', layers: 'layers' }, pct.appMode !== APP_MODES.STANDARD_DRAW);
+      const color = params.fill.color;
+      clear(layers.drawingCanvas, color); // Clear the offscreen canvas
+      initializeColorMode(layers.drawingCanvas, p5, params);
+    };
+
+    pct.clearCanvas({ layers, params });
+    undo = new UndoLayers(layers, renderLayers, 10);
+    pct.undo = undo;
+    undo.takeSnapshot();
+    pct.appMode = APP_MODES.STANDARD_DRAW;
+
+    // ... rest of setup
+  };
+
+  const mouseInCanvas = () => {
+    return p5.mouseY > 0 && p5.mouseY < p5.height && p5.mouseX > 0 && p5.mouseX < p5.width;
+  };
+
+  const standardDraw = ({ x, y, override, params } = { x: p5.mouseX, y: p5.mouseY, override: false, params: pct.params }) => {
+    if (override || (p5.mouseIsPressed && mouseInCanvas())) {
+      recordConfig(params, pct.appMode !== APP_MODES.STANDARD_DRAW);
+      
+      // 6. Translate mouse coordinates from the on-screen display to the off-screen canvas
+      const offscreenX = x * scaleFactor;
+      const offscreenY = y * scaleFactor;
+
+      recordAction({ x: offscreenX, y: offscreenY, action: 'paint' }, pct.appMode !== APP_MODES.STANDARD_DRAW);
+      paint(offscreenX, offscreenY, params);
+      globals.updatedCanvas = true;
+    }
+  };
+
+  const savit = ({ params }) => {
+    if (params.playbackSave || (params.capturing && globals.updatedCanvas)) {
+      // ...
+      // 7. Save the high-resolution offscreen canvas
+      saver(pct.layers.drawingCanvas.canvas, namer() + '.png');
+      // ...
+    }
+  };
+
+  p5.draw = () => {
+    // 8. Implement the new rendering pipeline
+    //    - Step 1: Clear the main, visible canvas with a neutral background
+    p5.background(200);
+    //    - Step 2: Draw the high-resolution off-screen canvas, scaled down to fit the viewport
+    p5.image(layers.drawingCanvas, 0, 0, p5.width, p5.height);
+    //    - Step 3: Draw the UI layer on top, without scaling
+    p5.image(layers.uiCanvas, 0, 0);
+    //    - Step 4: Clear the UI layer for the next frame
+    layers.uiCanvas.clear();
+
+    if (pct.params.autoPaint) {
+      // ...
+    } else {
+      // ...
+      switch (pct.appMode) {
+        // ...
+        default:
+          standardDraw();
+          break;
+      }
+    }
+    savit({ params: pct.params });
+  };
+
+  // ... other functions
+
+  const paint = (xPos, yPos, params) => {
+    // 9. Ensure all drawing operations target the off-screen canvas
+    const layer = layers.drawingCanvas;
+    setFont(params.font, layer);
+
+    if (params.drawMode === 'Grid') {
+      drawingModes.drawGrid({
+        xPos,
+        params,
+        width: params.width,
+        height: params.height,
+        layer,
+        textManager
+      });
+    } else if (params.drawMode === 'Circle') {
+      drawingModes.drawCircle({
+        xPos,
+        yPos,
+        params,
+        width: params.width,
+        height: params.height,
+        layer,
+        textManager
+      });
+    } else {
+      drawingModes.drawRowCol({
+        params,
+        width: params.width,
+        height: params.height,
+        layer,
+        textManager
+      });
+    }
+  };
+
+  // ... rest of the file
+}
+```
+
+### Step 3: Update `undo/undo.layers.js`
+
+The changes here are minimal, as most of the logic is handled by the updated `Layers` class.
+
+'''javascript
+// In undo/undo.layers.js
+
+// ... (no changes to constructor)
+
+    // ...
+
+    this.takeSnapshot = () => {
+      // This now correctly copies the drawingCanvas because layers.copy() was updated
+      const nextPosition = (newestPosition + 1) % maxStates;
+      images.store(layers.copy(), nextPosition);
+
+      // ...
+    };
+
+    // ...
+
+    this.show = () => {
+      // ...
+      const image = images.getImage(currentPosition);
+      // ...
+
+      // 1. Ensure the restored image is drawn to the offscreen canvas
+      layers.drawingCanvas.push();
+      layers.drawingCanvas.translate(0, 0);
+      layers.drawingCanvas.resetMatrix();
+      layers.drawingCanvas.image(image, 0, 0);
+      // The renderFunc is no longer needed here as the main draw loop handles rendering
+      // renderFunc({ layers }); 
+      layers.drawingCanvas.pop();
+    };
+
+    // ...
+'''
+
+### Summary of Changes
+
+1.  **`layers.js`:** The `Layers` class now creates and manages `drawingCanvas` and `uiCanvas`, abstracting away the complexity. The `copy()` method is updated to work with the `drawingCanvas`.
+2.  **`sketch.js`:**
+    *   `setup()` now creates a smaller `displayCanvas` and a larger `drawingCanvas` via the `Layers` class.
+    *   The `draw()` loop has a new rendering pipeline: clear, draw the scaled `drawingCanvas`, then draw the `uiCanvas`.
+    *   Mouse coordinates are now scaled up before being passed to drawing functions.
+    *   Saving now correctly targets the high-resolution `drawingCanvas`.
+    *   Drawing functions are now explicitly told to use `layers.drawingCanvas`.
+3.  **`undo/undo.layers.js`:** The `show()` method is updated to draw snapshots back to the `drawingCanvas`, ensuring the undo/redo history remains in high resolution. The call to `renderFunc` is removed as it's now redundant.
+
 
 ## 7. Testing Strategy
 
diff --git a/src/canvas-transforms/canvas-transforms.js b/src/canvas-transforms/canvas-transforms.js
index ae54eb2..e0a4177 100644
--- a/src/canvas-transforms/canvas-transforms.js
+++ b/src/canvas-transforms/canvas-transforms.js
@@ -14,7 +14,6 @@ import { flipCore, mirrorCore, newCorner, HORIZONTAL, VERTICAL } from './core-tr
  * @param {Function} dependencies.recordAction - Function to record actions for playback
  * @param {Object} dependencies.globals - Global state object
  * @param {Function} dependencies.renderLayers - Function to render layers to main canvas
- * @param {Function} dependencies.initDrawingLayer - Function to create new drawing layers
  * @param {Function} dependencies.getAppMode - Function that returns current app mode
  * @param {Object} dependencies.APP_MODES - App mode constants
  * @param {Object} dependencies.params - Global parameters object
@@ -25,7 +24,6 @@ export function createCanvasTransforms ({
   recordAction,
   globals,
   renderLayers,
-  initDrawingLayer,
   getAppMode,
   APP_MODES,
   params
@@ -35,12 +33,13 @@ export function createCanvasTransforms ({
    * @param {Object} config - Configuration object
    * @param {number} config.axis - HORIZONTAL or VERTICAL
    * @param {Object} config.layer - Target layer to flip
+   * TODO: except it does not use the passed-in layer sigh
    */
   const flip = ({ axis, layer }) => {
     recordAction({ axis, layer, action: 'flip' }, getAppMode() !== APP_MODES.STANDARD_DRAW)
 
     const newLayer = flipCore(axis, layers.copy(), layers)
-    layer.image(newLayer, 0, 0)
+    layers.drawingCanvas.image(newLayer, 0, 0)
     renderLayers({ layers })
     newLayer.remove()
     globals.updatedCanvas = true
@@ -52,12 +51,12 @@ export function createCanvasTransforms ({
    * @param {number} cfg.axis - HORIZONTAL or VERTICAL (default: VERTICAL)
    * @param {Object} cfg.layer - Target layer (default: layers.p5)
    */
-  const mirror = (cfg = { axis: VERTICAL, layer: layers.p5 }) => {
+  const mirror = (cfg = { axis: VERTICAL }) => {
     recordAction({ ...cfg, action: 'mirror' }, getAppMode() !== APP_MODES.STANDARD_DRAW)
 
     const tmp = layers.copy()
     const newLayer = mirrorCore(cfg.axis, tmp, layers)
-    cfg.layer.image(newLayer, 0, 0)
+    layers.drawingCanvas.image(newLayer, 0, 0)
     renderLayers({ layers })
     // Add defensive null check before removing - fix for parentNode error
     if (newLayer?.canvas?.parentNode) {
@@ -78,8 +77,7 @@ export function createCanvasTransforms ({
   const shift = (cfg = { verticalOffset: 0, horizontalOffset: 0 }) => {
     recordAction({ ...cfg, action: 'shift' }, getAppMode() !== APP_MODES.STANDARD_DRAW)
 
-    // TODO: has to be pointing to the drawingLayer
-    const context = layers.p5.drawingContext
+    const context = layers.drawingCanvas.drawingContext
     const imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height)
 
     const cw = (cfg.horizontalOffset > 0 ? context.canvas.width : -context.canvas.width)
@@ -106,12 +104,11 @@ export function createCanvasTransforms ({
    * @param {Object} config.layers - Layers object
    * @param {Object} config.p5 - p5.js instance
    */
-  const rotateCanvas = ({ direction = 1, height, width, layers: layersArg, p5 }) => {
+  const rotateCanvas = ({ direction = 1, height, width, layers }) => {
     recordAction({ action: 'rotateCanvas', direction, height, width }, getAppMode() !== APP_MODES.STANDARD_DRAW)
 
-    // Store current canvas content in drawing layer before resize
-    layersArg.drawingLayer.resetMatrix()
-    layersArg.drawingLayer.image(p5, 0, 0)
+    // because resize (below) will clear the canvas
+    const tempLayer = layers.copy()
 
     // Swap dimensions for 90-degree rotation
     const newWidth = height
@@ -121,11 +118,9 @@ export function createCanvasTransforms ({
     params.width = newWidth
     params.height = newHeight
 
-    // Resize main canvas (this clears it as a side-effect)
-    p5.resizeCanvas(newWidth, newHeight)
+    layers.resize(newWidth, newHeight)
 
-    // Create new graphics layer for rotated content
-    const newPG = initDrawingLayer(newWidth, newHeight)
+    const newPG = layers.drawingCanvas
     newPG.push()
 
     // Set rotation origin based on direction
@@ -136,16 +131,14 @@ export function createCanvasTransforms ({
     }
 
     // Apply 90-degree rotation and draw stored content
-    newPG.rotate(p5.radians(90 * direction))
-    newPG.image(layersArg.drawingLayer, 0, 0)
+    newPG.rotate(layers.p5.radians(90 * direction))
+    newPG.image(tempLayer, 0, 0)
     newPG.pop()
 
-    // Replace old drawing layer with rotated version
-    layersArg.drawingLayer.remove()
-    layersArg.drawingLayer = newPG
+    layers.dispose(tempLayer)
 
     // Note: Undo system doesn't track rotation operations
-    renderLayers({ layers: layersArg })
+    renderLayers({ layers })
     globals.updatedCanvas = true
   }
 
diff --git a/src/canvas-transforms/core-transforms.js b/src/canvas-transforms/core-transforms.js
index cfa094b..8444eac 100644
--- a/src/canvas-transforms/core-transforms.js
+++ b/src/canvas-transforms/core-transforms.js
@@ -17,6 +17,7 @@ export const VERTICAL = 1 // left=>right
  * @returns {Object} New flipped graphics object
  */
 export const flipCore = (axis = VERTICAL, sourceGraphics, layers) => {
+  // this default is ... stupid? because the first parameter cannot be optional
   const tmp = layers.clone(sourceGraphics)
   tmp.push()
   tmp.translate(0, 0)
@@ -43,7 +44,7 @@ export const flipCore = (axis = VERTICAL, sourceGraphics, layers) => {
  * @returns {Object} New mirrored graphics object
  */
 export const mirrorCore = (axis = VERTICAL, sourceGraphics, layers) => {
-  const tmp = flipCore(axis, sourceGraphics, layers)
+  const tmp = flipCore(axis, layers.copy(), layers)
 
   if (axis === HORIZONTAL) {
     sourceGraphics.image(tmp, 0, sourceGraphics.height / 2, sourceGraphics.width, sourceGraphics.height / 2, 0, sourceGraphics.height / 2, sourceGraphics.width, sourceGraphics.height / 2)
diff --git a/src/color/color-system.js b/src/color/color-system.js
index a5928a2..2852c48 100644
--- a/src/color/color-system.js
+++ b/src/color/color-system.js
@@ -8,7 +8,7 @@
 /**
  * Creates a color functions object with p5 instance and layers object captured in closure
  * @param {Object} p5Instance - The p5.js instance
- * @param {Object} layers - The layers object containing drawingLayer
+ * @param {Object} layers - The layers object containing drawingCanvas
  * @returns {Object} Object containing color functions
  */
 export function createColorFunctions (p5Instance, layers) {
@@ -34,7 +34,7 @@ export function createColorFunctions (p5Instance, layers) {
    */
   const setPaintMode = (props) => {
     const { func, gridX, gridY, params, hexStringToColors } = props
-    const layer = layers.drawingLayer
+    const layer = layers.drawingCanvas
     const boundFunc = func.bind(layer)
     const transparency = params.transparent ? parseInt(params.transparency, 10) / 100 : 1
 
@@ -145,7 +145,7 @@ export function createColorFunctions (p5Instance, layers) {
    * @param {Function} hexStringToColors - Function to parse hex color strings
    */
   const setFillMode = (xPos, yPos, params, hexStringToColors) =>
-    setPaintMode({ gridX: xPos, gridY: yPos, params, func: layers.drawingLayer.fill, hexStringToColors })
+    setPaintMode({ gridX: xPos, gridY: yPos, params, func: layers.drawingCanvas.fill, hexStringToColors })
 
   /**
    * Creates outline mode function for the layer
@@ -155,7 +155,7 @@ export function createColorFunctions (p5Instance, layers) {
    * @param {Function} hexStringToColors - Function to parse hex color strings
    */
   const setOutlineMode = (xPos, yPos, params, hexStringToColors) =>
-    setPaintMode({ gridX: xPos, gridY: yPos, params, func: layers.drawingLayer.stroke, hexStringToColors })
+    setPaintMode({ gridX: xPos, gridY: yPos, params, func: layers.drawingCanvas.stroke, hexStringToColors })
 
   return {
     colorAlpha,
@@ -210,7 +210,7 @@ export function createGammaAdjustment (dependencies) {
  * @param {Object} params - Parameters object with width/height
  * @returns {Object} The layer (for chaining)
  */
-export function initializeColorMode (layer, p5Instance, params) {
-  layer.colorMode(p5Instance.HSB, params.width, params.height, 100, 1)
-  return layer
-}
+// export function initializeColorMode (layer, p5Instance, params) {
+//   layer.colorMode(p5Instance.HSB, params.width, params.height, 100, 1)
+//   return layer
+// }
diff --git a/src/drawing-modes/grid-painter.js b/src/drawing-modes/grid-painter.js
index 58c4ed7..9076c8e 100644
--- a/src/drawing-modes/grid-painter.js
+++ b/src/drawing-modes/grid-painter.js
@@ -87,6 +87,8 @@ export const createGridPainter = (dependencies) => {
 
     layer.textSize(gridParams.step)
     // This is weird - textAscent goes to the parent p5 instance which is set to 12
+    // TODO: document this weirdness (source I mean, in the code? still?)
+    // used below: const yOffset = getYoffset(layer.textAscent(), 0)
     layers.p5.textSize(gridParams.step)
 
     // Configure stroke
diff --git a/src/drawing-modes/rowcol-painter.js b/src/drawing-modes/rowcol-painter.js
index 4d55e44..bb25be8 100644
--- a/src/drawing-modes/rowcol-painter.js
+++ b/src/drawing-modes/rowcol-painter.js
@@ -76,8 +76,8 @@ export const createRowColPainter = (dependencies) => {
 
     // Call renderLayers to display results
     const renderLayers = ({ layers }) => {
-      layers.p5.image(layers.drawingLayer, 0, 0)
-      layers.drawingLayer.clear()
+      layers.p5.image(layers.drawingCanvas, 0, 0)
+      layers.drawingCanvas.clear()
     }
     renderLayers({ layers })
 
diff --git a/src/gui/actions.js b/src/gui/actions.js
index 990b68b..c999c6d 100644
--- a/src/gui/actions.js
+++ b/src/gui/actions.js
@@ -38,7 +38,7 @@ const setupActions = (pct) => {
     {
       action: ({ layers }) => {
         pct.undo.takeSnapshot()
-        pct.newCorner(layers.drawingLayer)
+        pct.newCorner(layers.drawingCanvas)
       }
     },
     {
@@ -78,16 +78,16 @@ const setupActions = (pct) => {
       }
     },
     {
-      action: ({ params }) => {
+      action: ({ params, layers }) => {
         pct.undo.takeSnapshot()
-        pct.rotateCanvas({ direction: 1, height: params.height, width: params.width, layers: pct.layers })
+        pct.rotateCanvas({ direction: 1, height: params.height, width: params.width, layers })
         pct.globals.updatedCanvas = true
       }
     },
     {
-      action: ({ params }) => {
+      action: ({ params, layers }) => {
         pct.undo.takeSnapshot()
-        pct.rotateCanvas({ direction: -1, height: params.height, width: params.width, layers: pct.layers })
+        pct.rotateCanvas({ direction: -1, height: params.height, width: params.width, layers })
         pct.globals.updatedCanvas = true
       }
     },
diff --git a/src/gui/keys.js b/src/gui/keys.js
index 17a1cf0..3c19eb2 100644
--- a/src/gui/keys.js
+++ b/src/gui/keys.js
@@ -42,7 +42,7 @@ const setupHotkeys = (pct) => {
       keys: 'a',
       action: ({ layers }) => {
         pct.undo.takeSnapshot()
-        pct.newCorner(layers.drawingLayer)
+        pct.newCorner(layers.drawingCanvas)
       }
     },
     {
@@ -74,10 +74,6 @@ const setupHotkeys = (pct) => {
         pct.adjustGamma({ gamma: params.gamma })
       }
     },
-    {
-      keys: 'alt+t',
-      action: () => pct.target() // this doesn't really do anything yet....
-    },
     {
       keys: ['f', 'shift+f'].join(','),
       action: () => {
@@ -112,12 +108,6 @@ const setupHotkeys = (pct) => {
         params.useOutline = !params.useOutline
       }
     },
-    {
-      keys: ['p'].join(','),
-      action: ({ params }) => {
-        params.target = !params.target
-      }
-    },
     {
       keys: ['q'].join(','),
       action: ({ params, layers }) => {
@@ -136,7 +126,7 @@ const setupHotkeys = (pct) => {
     {
       keys: ['r', 'shift+r'].join(','),
       action: ({ params, layers }) => {
-        pct.reset(params, layers.drawingLayer)
+        pct.reset(params, layers.drawingCanvas)
       }
     },
     // {
@@ -151,7 +141,7 @@ const setupHotkeys = (pct) => {
       keys: ['t'].join(','),
       action: ({ layers }) => {
         pct.undo.takeSnapshot()
-        pct.mirror({ axis: VERTICAL, layer: layers.p5 })
+        pct.mirror({ axis: VERTICAL, layers })
       }
     },
     {
diff --git a/src/gui/macros.js b/src/gui/macros.js
index 8e87c04..9900612 100644
--- a/src/gui/macros.js
+++ b/src/gui/macros.js
@@ -9,7 +9,7 @@ export default function Macros (pchrome) {
   // TODO: record needs to happen here
   const macroWrapper = m => (pct) => {
     pct.undo.takeSnapshot()
-    const { params, layers: { drawingLayer: layer }, p5, defaultParams } = pct
+    const { params, layers: { drawingCanvas: layer }, p5, defaultParams } = pct
     layer.push()
     m({ params: JSON.parse(JSON.stringify(params)), layer, p5, defaultParams })
     if (m.name) {
diff --git a/src/layers.js b/src/layers.js
index 1f71511..d870748 100644
--- a/src/layers.js
+++ b/src/layers.js
@@ -1,19 +1,89 @@
 export default class Layers {
-  constructor (p5, dl, temp) {
+  constructor (p5, params, setFont) {
     this.p5 = p5
-    this.drawingLayer = dl // p5.Graphics
-    this.tempLayer = temp
+    this.params = params
+    this.setFont = setFont
+
+    this.scaleFactor = 1 // Initial value, will be updated by resize
+    this.width = params.width
+    this.height = params.height
+
+    // Create initial canvases
+    this.resize(this.width, this.height)
   }
 
+  _createLayer (w, h) {
+    const layer = this.p5.createGraphics(w, h)
+    layer.pixelDensity(this.p5.pixelDensity())
+    this.setFont(this.params.font, layer)
+    layer.textAlign(this.p5.CENTER, this.p5.CENTER)
+    this.initializeColorMode(layer, this.params)
+    return layer
+  }
+
+  resize (newWidth, newHeight, copyContent = false) {
+    this.width = newWidth
+    this.height = newHeight
+
+    const maxDisplayWidth = 1025
+    const maxDisplayHeight = 650
+
+    const widthRatio = this.width / maxDisplayWidth
+    const heightRatio = this.height / maxDisplayHeight
+
+    if (this.width > maxDisplayWidth || this.height > maxDisplayHeight) {
+      this.scaleFactor = Math.max(widthRatio, heightRatio)
+    } else {
+      this.scaleFactor = 1
+    }
+
+    const displayWidth = this.width / this.scaleFactor
+    const displayHeight = this.height / this.scaleFactor
+
+    // Resize main canvas
+    this.p5.resizeCanvas(displayWidth, displayHeight)
+
+    // Preserve old drawing canvas content if requested
+    const oldDrawingCanvas = this.drawingCanvas
+    const oldUiCanvas = this.uiCanvas
+
+    // Create new canvases
+    this.drawingCanvas = this._createLayer(this.width, this.height)
+    this.uiCanvas = this.p5.createGraphics(displayWidth, displayHeight)
+    this.uiCanvas.pixelDensity(this.p5.pixelDensity())
+
+    // Copy content from old to new drawing canvas if requested
+    if (copyContent && oldDrawingCanvas) {
+      this.drawingCanvas.image(oldDrawingCanvas, 0, 0)
+    }
+
+    if (oldDrawingCanvas) {
+      oldDrawingCanvas.remove()
+    }
+    if (oldUiCanvas) {
+      oldUiCanvas.remove()
+    }
+  }
+
+  clear (backgroundColor) {
+    this.drawingCanvas.background(backgroundColor)
+  }
+
+  initializeColorMode = (layer, params) => {
+    layer.colorMode(this.p5.HSB, params.width, params.height, 100, 1)
+    return layer
+  }
+
+
   /**
-   * Returns a p5.Graphics object that is a copy of the current drawing.
+   * Returns a p5.Graphics object that is a copy of the offscreen canvas.
    * CALLER OWNS THE RETURNED GRAPHICS - must call dispose() or .remove() when done.
-   * @returns {p5.Graphics} A new graphics object containing a copy of the current drawing
+   * @returns {p5.Graphics} A new graphics object containing a copy of the offscreen canvas.
    */
-  copy () {
-    const layer = this.p5.createGraphics(this.p5.width, this.p5.height)
+  copy() {
+    const layer = this.p5.createGraphics(this.width, this.height)
     layer.pixelDensity(this.p5.pixelDensity())
-    layer.image(this.p5, 0, 0)
+    layer.image(this.drawingCanvas, 0, 0)
     return layer
   }
 
@@ -23,7 +93,7 @@ export default class Layers {
    * @param {p5.Image|p5.Graphics} img The image to clone
    * @returns {p5.Graphics} A new graphics object containing a copy of the input image
    */
-  clone (img) {
+  clone(img) {
     const g = this.p5.createGraphics(img.width, img.height)
     g.pixelDensity(this.p5.pixelDensity())
     g.image(img, 0, 0)
@@ -35,29 +105,25 @@ export default class Layers {
    * Safe to call on any p5.Graphics object.
    * @param {p5.Graphics} graphics The graphics object to dispose
    */
-  dispose (graphics) {
+  dispose(graphics) {
     if (graphics?.canvas) {
       graphics.remove()
     }
   }
 
   /**
-   * Set font for both main canvas and drawing layer.
-   * Text rendering is core to this painting application.
+   * Set font for the offscreen canvas.
    * @param {p5.Font|string} font The font to use for text rendering
    */
-  setFont (font) {
-    this.p5.textFont(font)
-    this.drawingLayer.textFont(font)
+  setFont(font) {
+    this.drawingCanvas.textFont(font)
   }
 
   /**
-   * Set text size for both main canvas and drawing layer.
-   * Text rendering is core to this painting application.
+   * Set text size for the offscreen canvas.
    * @param {number} size The size of text in pixels
    */
-  textSize (size) {
-    this.p5.textSize(size)
-    this.drawingLayer.textSize(size)
+  textSize(size) {
+    this.drawingCanvas.textSize(size)
   }
 }
diff --git a/src/sketch.js b/src/sketch.js
index d8dedac..e81a6da 100644
--- a/src/sketch.js
+++ b/src/sketch.js
@@ -1,19 +1,13 @@
 import UndoLayers from '@/src/undo/undo.layers.js'
 import Layers from '@/src/layers.js'
-import {
-  allParams,
-  fillParams,
-  outlineParams,
-  drawModes,
-  globals
-} from '@/src/params.js'
+import { allParams, fillParams, outlineParams, drawModes, globals } from '@/src/params.js'
 import { hexStringToColors } from '@/src/gui/gui.color.control'
 import { setupGui } from '@/src/gui/gui'
 import { recordAction, recordConfig, output, clear as clearRecording } from '@/src/scripting/record'
 import saveAs from 'file-saver'
 import { datestring, filenamer } from '@/src//filelib'
 import { setupActions } from '@/src/gui/actions'
-import { createColorFunctions, createGammaAdjustment, initializeColorMode } from '@/src/color/color-system'
+import { createColorFunctions, createGammaAdjustment } from '@/src/color/color-system'
 import { createCanvasTransforms } from '@/src/canvas-transforms'
 import { createDrawingModes } from '@/src/drawing-modes'
 import { apx, pushpop } from '@/src/utils'
@@ -27,6 +21,7 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
   const pct = {}
 
   const density = 2
+  let scaleFactor = 1
 
   let layers
   let colorSystem
@@ -37,8 +32,6 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
 
   const fontList = {}
 
-  // TODO: we can clean this up to be simpler and consistent
-  // POC it works
   const loadedFonts = fonts.keys().map(f => f.replace(/\.\/(.*?)\.ttf/, '$1'))
 
   let imgMask
@@ -49,7 +42,6 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
     imgMask = p5.loadImage(require('~/assets/9-96398_http-landrich-black-gradient-border-transparent.png'))
   }
 
-  // because the image I got was inverted from what I need.
   const invertMask = () => {
     imgMask.loadPixels()
     for (let i = 3; i < imgMask.pixels.length; i += 4) {
@@ -68,16 +60,27 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
   p5.setup = () => {
     invertMask()
     p5.pixelDensity(density)
-    // TODO: so, you were wondering why there were too many canvases? !!!
-    p5.createCanvas(params.width, params.height) // canvas 1
-    const drawingLayer = initDrawingLayer(params.width, params.height) // canvas 2
-    const tempLayer = initDefaultLayer(params.width, params.height) // canvas 3
-    pct.layers = layers = new Layers(p5, drawingLayer, tempLayer)
 
-    // Initialize color system
+    const maxDisplayWidth = 1025
+    const maxDisplayHeight = 650
+
+    const widthRatio = params.width / maxDisplayWidth
+    const heightRatio = params.height / maxDisplayHeight
+
+    if (params.width > maxDisplayWidth || params.height > maxDisplayHeight) {
+      scaleFactor = Math.max(widthRatio, heightRatio)
+    } else {
+      scaleFactor = 1
+    }
+
+    const displayWidth = params.width / scaleFactor
+    const displayHeight = params.height / scaleFactor
+    p5.createCanvas(displayWidth, displayHeight)
+
+    pct.layers = layers = new Layers(p5, params, setFont)
+
     colorSystem = createColorFunctions(p5, layers)
 
-    // Initialize gamma adjustment with dependencies
     adjustGamma = createGammaAdjustment({
       layers,
       recordAction,
@@ -87,27 +90,27 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
       APP_MODES
     })
 
-    // Initialize canvas transforms with dependencies
     canvasTransforms = createCanvasTransforms({
       layers,
       recordAction,
       globals,
       renderLayers,
-      initDrawingLayer,
       getAppMode: () => pct.appMode,
       APP_MODES,
       params
     })
 
-    // Initialize drawing modes with dependencies
+    // TODO: layers s/b complete, expect p5 f'r instance
     drawingModes = createDrawingModes({
+      // layers: { drawingCanvas: layers.drawingCanvas },
       layers,
+      // layers: { ...layers, drawingCanvas: layers.drawingCanvas },
       colorSystem,
       hexStringToColors,
       p5
     })
 
-    const { shiftFillColors, shiftOutlineColors } = setupGui({ p5, sketch: pct, params, fillParams: params.fill, outlineParams: params.outline })
+    const { shiftFillColors, shiftOutlineColors } = setupGui({ p5, sketch: pct, params, fillParams: params.fill, outlineParams: params.outline, handleResize })
     pct.shiftFillColors = shiftFillColors
     pct.shiftOutlineColors = shiftOutlineColors
 
@@ -123,7 +126,6 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
 
     pct.adjustGamma = adjustGamma
 
-    // Assign canvas transforms to pct object
     pct.flip = canvasTransforms.flip
     pct.flipCore = canvasTransforms.flipCore
     pct.mirror = canvasTransforms.mirror
@@ -134,7 +136,6 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
     pct.HORIZONTAL = canvasTransforms.HORIZONTAL
     pct.VERTICAL = canvasTransforms.VERTICAL
 
-    // Assign drawing modes to pct object
     pct.drawGrid = drawingModes.drawGrid
     pct.drawCircle = drawingModes.drawCircle
     pct.drawRowCol = drawingModes.drawRowCol
@@ -143,14 +144,11 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
     recordConfig(pct.params, pct.appMode === APP_MODES.STANDARD_DRAW)
   }
 
-  // NOTE: not working
-  // swap paint (fill/stroke) params
-  // pct.swapParams = () => {
-  //   const temp = { ...pct.params.fill }
-  //   pct.params.fill = { ...pct.params.outline }
-  //   pct.params.outline = temp
-  //   console.log('flipped!')
-  // }
+  const handleResize = () => {
+    layers.resize(params.width, params.height)
+    undo.clear()
+    undo.takeSnapshot()
+  }
 
   const mouseInCanvas = () => {
     return p5.mouseY > 0 && p5.mouseY < p5.height && p5.mouseX > 0 && p5.mouseX < p5.width
@@ -159,8 +157,10 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
   const standardDraw = ({ x, y, override, params } = { x: p5.mouseX, y: p5.mouseY, override: false, params: pct.params }) => {
     if (override || (p5.mouseIsPressed && mouseInCanvas())) {
       recordConfig(params, pct.appMode !== APP_MODES.STANDARD_DRAW)
-      recordAction({ x, y, action: 'paint' }, pct.appMode !== APP_MODES.STANDARD_DRAW)
-      paint(x, y, params)
+      const offscreenX = x * scaleFactor
+      const offscreenY = y * scaleFactor
+      recordAction({ x: offscreenX, y: offscreenY, action: 'paint' }, pct.appMode !== APP_MODES.STANDARD_DRAW)
+      paint(offscreenX, offscreenY, params)
       globals.updatedCanvas = true
     }
   }
@@ -182,7 +182,7 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
       }
       console.log('saving canvas: ' + globals.captureCount)
 
-      saver(pct.layers.p5.drawingContext.canvas, namer() + '.png')
+      saver(pct.layers.drawingCanvas.canvas, namer() + '.png')
 
       globals.captureCount += 1
       if (globals.captureCount > pct.params.captureLimit) {
@@ -194,10 +194,14 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
   }
 
   p5.draw = () => {
+    p5.background(200)
+    p5.image(layers.drawingCanvas, 0, 0, p5.width, p5.height)
+    p5.image(layers.uiCanvas, 0, 0)
+    layers.uiCanvas.clear()
+
     if (pct.params.autoPaint) {
       autoDraw(0, 0, p5.width, p5.height)
     } else {
-      // increment incremental things
       increment(pct.params)
 
       switch (pct.appMode) {
@@ -215,27 +219,8 @@ export default function Sketch ({ p5Instance: p5, guiControl, textManager, setup
     savit({ params: pct.params })
   }
 
-  /**
- *
- *
- *
- * func(colorAlpha(params.color, transparency))}
- *
- * var i = 0, colour;
-for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
-    colour = '#' + ('00000' + i.toString(16)).slice(-6); // pad to 6 digits
-    // #000000
-    // #000001
-    // ... #000100 ...
-    // #FFFFFE
-    // #FFFFFF
-} you know, maybe I should this in a sketch.....
- */
-
   const increment = (params) => {
-    // TODO: implement something to move from value A to value B over set of steps
     pct.skewCollection.forEach(skew => {
-      // TODO: iterate each
       skew.next()
     })
   }
@@ -246,10 +231,7 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
     }
   }
 
-  // TODO: perlin noise on the randoms, with jumps every n frames
-  // random application of other controls (macros, etc ?)
-  // rotate canvas, mirror, etc.
-  // Can we move this out of here, like playback?
+  // NOTE: these are different "actions" that what are recorded or played-back
   const actions = setupActions(pct)
 
   const autoDraw = (minX, minY, maxX, maxY) => {
@@ -269,67 +251,38 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
     globals.updatedCanvas = true
   }
 
-  // this was a POC-WIP for picking the center for various operations
-  // never finished
-  const target = () => {
-    const layer = layers.copy()
-
-    p5.image(layer)
-    // layers.tempLayer.clear()
-    const x = p5.mouseX
-    const y = p5.mouseY
-    p5.line(0, y, p5.width, y) // line(0, y, width, y);
-    p5.line(x, 0, x, p5.height) // line(0, y, width, y);
-    layer.remove()
-  }
-
+  // move to layers class ???
   const renderLayers = ({ layers }) => {
     renderTarget({ layers })
   }
 
+  // move to layers class
   const renderTarget = ({ layers }) => {
-    layers.p5.image(layers.drawingLayer, 0, 0)
-    layers.drawingLayer.clear()
+    layers.p5.image(layers.drawingCanvas, 0, 0)
+    // layers.drawingCanvas.clear()
   }
 
   const clearCanvas = ({ layers, params }) => {
     recordAction({ action: 'clearCanvas', layers: 'layers' }, pct.appMode !== APP_MODES.STANDARD_DRAW)
-    const color = params.fill.color
-    clear(layers.drawingLayer, color)
-    clear(layers.p5, color)
-
-    initializeColorMode(layers.drawingLayer, p5, params)
-  }
-
-  const clear = (layer, color) => {
-    layer.resizeCanvas(pct.params.width, pct.params.height)
-    layer.pixelDensity(density)
-    layer.background(color)
+    layers.resize(params.width, params.height)
+    layers.clear(params.fill.color)
+    layers.initializeColorMode(layers.drawingCanvas, params)
+    // undo.clear()
+    // undo.takeSnapshot()
   }
 
-  const setFont = (font, layer = layers.drawingLayer) => {
-    // how clumsy! but as a POC it works
+  // move to layers class ???
+  // maybe not - this is only about drawing
+  // ugh, but it is called from initDrawingLayer SIGH
+  const setFont = (font, layer = layers.drawingCanvas) => {
     const tf = (loadedFonts.includes(font)) ? fontList[font] : font
     layer.textFont(tf)
   }
 
-  const initDefaultLayer = (w, h) => {
-    const layer = p5.createGraphics(w, h)
-    layer.pixelDensity(density)
-    return layer
-  }
-
-  const initDrawingLayer = (w, h) => {
-    const layer = initDefaultLayer(w, h)
-    setFont(params.font, layer)
-    layer.textAlign(p5.CENTER, p5.CENTER)
-    initializeColorMode(layer, p5, params)
-
-    return layer
-  }
-
+  // s/b taking in a layer not assuming a layer
   const paint = (xPos, yPos, params) => {
-    setFont(params.font, layers.drawingLayer)
+    const layer = layers.drawingCanvas
+    setFont(params.font, layer)
 
     if (params.drawMode === 'Grid') {
       drawingModes.drawGrid({
@@ -337,10 +290,9 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
         params,
         width: params.width,
         height: params.height,
-        layer: layers.drawingLayer,
+        layer,
         textManager
       })
-      renderLayers({ layers })
     } else if (params.drawMode === 'Circle') {
       drawingModes.drawCircle({
         xPos,
@@ -348,17 +300,15 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
         params,
         width: params.width,
         height: params.height,
-        layer: layers.drawingLayer,
+        layer,
         textManager
       })
-      renderLayers({ layers })
     } else {
-      // Use modular RowCol painter
       drawingModes.drawRowCol({
         params,
         width: params.width,
         height: params.height,
-        layer: layers.drawingLayer,
+        layer,
         textManager
       })
     }
@@ -380,7 +330,6 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
     layer.drawingContext.shadowColor = params.shadowColor
   }
 
-  // TODO: hah this does not work
   const nextDrawMode = (direction, params) => {
     let drawMode = params.drawMode
     drawMode = (drawMode + direction) % drawModes.length
@@ -395,13 +344,13 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
     if (params.rotation < -360) { params.rotation = -360 }
   }
 
-  // only resets the angle, for now...
   const reset = (params, layer) => {
     params.rotation = 0
     layer.translate(0, 0)
     layer.resetMatrix()
   }
 
+  // why redefine the util functions each time???
   pct.save_sketch = () => {
     const getDateFormatted = () => {
       const d = new Date()
@@ -413,63 +362,53 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
       nbr = nbr + ''
       return nbr.length >= width ? nbr : new Array(width - nbr.length + 1).join(fill) + nbr
     }
-    p5.saveCanvas(`${params.name}.${getDateFormatted()}.png`)
+    p5.save(layers.drawingCanvas, `${params.name}.${getDateFormatted()}.png`)
   }
 
+  // TODO: move into a util object
   const coinflip = () => pct.p5.random() > 0.5
 
-  // place image from history into location in current image
-  // with (optional) rotation, transparency, mask and size
   const randomLayer = (cfg = {}) => {
     const img = pct.p5.random(pct.undo.history())
-    layers.drawingLayer.push()
+    layers.drawingCanvas.push()
     pct.p5.push()
 
     try {
-      layers.drawingLayer.resetMatrix()
+      layers.drawingCanvas.resetMatrix()
 
-      // can be negative, but to appear it depends on the size percentage
       const pctSize = cfg.percentSize || percentSize()
-      // this is an approximation, an does not take rotation into account
       const size = { width: pct.p5.width * pctSize, height: pct.p5.height * pctSize }
       const offsetSize = { width: size.width * 0.75, height: size.height * 0.75 }
-      const originX = cfg.originX || pct.p5.random(-offsetSize.width, pct.p5.width + offsetSize.width) // should be able to go BACK and UP as well
+      const originX = cfg.originX || pct.p5.random(-offsetSize.width, pct.p5.width + offsetSize.width)
       const originY = cfg.originY || pct.p5.random(-offsetSize.height, pct.p5.height + offsetSize.height)
-      layers.drawingLayer.translate(originX, originY)
-      // TODO: hrm. maybe there could be some more options, here?
+      layers.drawingCanvas.translate(originX, originY)
 
       const rotateP = cfg.rotateP || coinflip()
       const radians = cfg.radians || pct.p5.random(360)
-      if (rotateP) { layers.drawingLayer.rotate(pct.p5.radians(radians)) }
-      // this is a POC
-      // I'd like to explore gradients or other masks for transparency
+      if (rotateP) { layers.drawingCanvas.rotate(pct.p5.radians(radians)) }
+
       const alpha = cfg.alpha || pct.p5.random(255)
 
-      // hey! the density is all off, here
       const img2 = layers.p5.createGraphics(img.width, img.height)
 
       img2.copy(img, 0, 0, img.width, img.height, 0, 0, img.width * pctSize, img.height * pctSize)
       if (!params.hardEdge) {
-        // literally this is using a mask image
-        // which is an interesting idea but the code here is broken
-        // and the option name and GUI display are not intuitive
         const mask2 = layers.p5.createImage(img.width, img.height)
         mask2.copy(imgMask, 0, 0, img.width, img.height, 0, 0, img.width * pctSize, img.height * pctSize)
-        img2.mask(mask2) // TODO: need to modify by size, as well
+        img2.mask(mask2)
       }
 
       pct.p5.tint(255, alpha)
-      setShadows(layers.drawingLayer, params)
+      setShadows(layers.drawingCanvas, params)
 
-      layers.drawingLayer.image(img2, 0, 0)
-      renderTarget({ layers }) // not all layers - skip clearing and background, thus allowing an overlay
+      layers.drawingCanvas.image(img2, 0, 0)
 
       recordAction({ action: 'randomLayer', percentSize: pctSize, originX, originY, rotateP, radians, alpha }, pct.appMode !== APP_MODES.STANDARD_DRAW)
     } catch (e) {
       console.log(e)
     } finally {
       pct.p5.pop()
-      layers.drawingLayer.pop()
+      layers.drawingCanvas.pop()
     }
     globals.updatedCanvas = true
   }
@@ -491,7 +430,6 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
     p5.loop()
   }
 
-  // this smells, but is a start of separation
   pct.apx = apx
   pct.clearCanvas = clearCanvas
   pct.guiControl = guiControl
@@ -506,7 +444,6 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
   pct.renderLayers = renderLayers
   pct.reset = reset
   pct.setFont = setFont
-  pct.target = target
   pct.textManager = textManager
   pct.mouseInCanvas = mouseInCanvas
   pct.draw = standardDraw
@@ -516,7 +453,7 @@ for (; i < 16777216; ++i) { // this is a BIG loop, will freeze/crash a browser!
   pct.recordAction = recordAction
   pct.recordConfig = recordConfig
   pct.globals = globals
-  pct.skewCollection = []
+  pct.skewCollection = [] // TODO: this is interesting, a stub I had forgotten about
   pct.savit = savit
   pct.textManager = textManager
 
diff --git a/src/undo/undo.layers.js b/src/undo/undo.layers.js
index 49bc583..76c9e4f 100644
--- a/src/undo/undo.layers.js
+++ b/src/undo/undo.layers.js
@@ -118,13 +118,18 @@ export default class UndoLayers {
         return
       }
 
-      // Handle rendering with proper graphics state management
-      layers.drawingLayer.push()
-      layers.drawingLayer.translate(0, 0)
-      layers.drawingLayer.resetMatrix()
-      layers.drawingLayer.image(image, 0, 0)
-      renderFunc({ layers })
-      layers.drawingLayer.pop()
+      layers.drawingCanvas.push()
+      layers.drawingCanvas.translate(0, 0)
+      layers.drawingCanvas.resetMatrix()
+      layers.drawingCanvas.image(image, 0, 0)
+      layers.drawingCanvas.pop()
+    }
+
+    this.clear = () => {
+      currentPosition = -1
+      newestPosition = -1
+      availableStates = 0
+      images.clear()
     }
 
     this.history = () => {
@@ -178,5 +183,14 @@ class ImageCollection {
     }
 
     this.all = () => imgs
+
+    this.clear = () => {
+      for (let i = 0; i < amount; i++) {
+        if (imgs[i]) {
+          layers.dispose(imgs[i])
+          imgs[i] = null
+        }
+      }
+    }
   }
 }
diff --git a/test/undo.layers.test.js b/test/undo.layers.test.js
index b533d10..5632bc5 100644
--- a/test/undo.layers.test.js
+++ b/test/undo.layers.test.js
@@ -5,7 +5,7 @@ import UndoLayers from '../src/undo/undo.layers.js'
 const createMockLayers = () => ({
   copy: vi.fn(() => ({ id: Math.random(), mock: 'layer' })),
   dispose: vi.fn(),
-  drawingLayer: {
+  offscreenCanvas: {
     push: vi.fn(),
     pop: vi.fn(),
     translate: vi.fn(),
@@ -25,7 +25,7 @@ describe('UndoLayers', () => {
   beforeEach(() => {
     layers = createMockLayers()
     renderFunc = createMockRenderFunc()
-    undoLayers = new UndoLayers(layers, renderFunc, 5) // Small buffer for testing
+    undoLayers = new UndoLayers(layers, null, 5) // Small buffer for testing
   })
 
   describe('takeSnapshot', () => {
@@ -65,7 +65,7 @@ describe('UndoLayers', () => {
       undoLayers.takeSnapshot() // This should clear redo
 
       undoLayers.redo() // Should do nothing
-      expect(renderFunc).toHaveBeenCalledTimes(1) // Only from undo
+
     })
   })
 
@@ -73,7 +73,7 @@ describe('UndoLayers', () => {
     it('should not undo when no snapshots available', () => {
       undoLayers.undo()
 
-      expect(renderFunc).not.toHaveBeenCalled()
+
     })
 
     it('should undo one step', () => {
@@ -82,7 +82,6 @@ describe('UndoLayers', () => {
 
       undoLayers.undo()
 
-      expect(renderFunc).toHaveBeenCalledTimes(1)
       expect(layers.drawingLayer.push).toHaveBeenCalled()
       expect(layers.drawingLayer.pop).toHaveBeenCalled()
     })
@@ -95,7 +94,7 @@ describe('UndoLayers', () => {
       undoLayers.undo()
       undoLayers.undo()
 
-      expect(renderFunc).toHaveBeenCalledTimes(2)
+
     })
 
     it('should not undo beyond available history', () => {
@@ -114,7 +113,7 @@ describe('UndoLayers', () => {
       undoLayers.takeSnapshot()
       undoLayers.redo()
 
-      expect(renderFunc).not.toHaveBeenCalled()
+
     })
 
     it('should redo after undo', () => {
@@ -124,7 +123,7 @@ describe('UndoLayers', () => {
 
       undoLayers.redo()
 
-      expect(renderFunc).toHaveBeenCalledTimes(2) // Once for undo, once for redo
+ // Once for undo, once for redo
     })
 
     it('should handle multiple redo steps', () => {
@@ -137,7 +136,7 @@ describe('UndoLayers', () => {
       undoLayers.redo()
       undoLayers.redo()
 
-      expect(renderFunc).toHaveBeenCalledTimes(4) // 2 undos + 2 redos
+
     })
 
     it('should not redo beyond available redo history', () => {
@@ -148,7 +147,7 @@ describe('UndoLayers', () => {
       undoLayers.redo()
       undoLayers.redo() // Should do nothing
 
-      expect(renderFunc).toHaveBeenCalledTimes(2) // 1 undo + 1 redo
+ // 1 undo + 1 redo
     })
 
     // New test for intermittent redo failure
@@ -172,7 +171,7 @@ describe('UndoLayers', () => {
   describe('circular buffer behavior', () => {
     it('should handle buffer wraparound correctly', () => {
       const bufferSize = 3
-      const undoSmall = new UndoLayers(layers, renderFunc, bufferSize)
+      const undoSmall = new UndoLayers(layers, null, bufferSize)
 
       // Fill buffer and go beyond
       for (let i = 0; i < bufferSize + 2; i++) {
@@ -186,7 +185,7 @@ describe('UndoLayers', () => {
 
     it('should maintain undo/redo consistency after wraparound', () => {
       const bufferSize = 3
-      const undoSmall = new UndoLayers(layers, renderFunc, bufferSize)
+      const undoSmall = new UndoLayers(layers, null, bufferSize)
 
       // Fill buffer and go beyond
       for (let i = 0; i < bufferSize + 1; i++) {
@@ -205,7 +204,7 @@ describe('UndoLayers', () => {
       // - We keep the 3 most recent snapshots
       // - We can undo 2 times (from newest to oldest-available)
       // - Both undos should render
-      expect(renderFunc).toHaveBeenCalledTimes(2)
+
 
       // Should be able to redo
       undoSmall.redo()
@@ -215,7 +214,7 @@ describe('UndoLayers', () => {
 
     it('should handle edge case at exactly buffer size', () => {
       const bufferSize = 3
-      const undoSmall = new UndoLayers(layers, renderFunc, bufferSize)
+      const undoSmall = new UndoLayers(layers, null, bufferSize)
 
       // Fill buffer exactly
       for (let i = 0; i < bufferSize; i++) {
@@ -234,7 +233,7 @@ describe('UndoLayers', () => {
     // New test for the specific modulo edge case
     it('should handle redo at buffer size boundaries', () => {
       const bufferSize = 5
-      const undoSmall = new UndoLayers(layers, renderFunc, bufferSize)
+      const undoSmall = new UndoLayers(layers, null, bufferSize)
 
       // Fill buffer to exactly the size
       for (let i = 0; i < bufferSize; i++) {
@@ -252,7 +251,7 @@ describe('UndoLayers', () => {
       undoSmall.redo()
       undoSmall.redo()
 
-      expect(renderFunc).toHaveBeenCalledTimes(4) // 2 undos + 2 redos
+
     })
   })
 
@@ -307,7 +306,7 @@ describe('UndoLayers', () => {
       undoLayers.redo()
 
       // Should not throw and should render correctly
-      expect(renderFunc).toHaveBeenCalledTimes(3) // 2 undos + 1 redo
+
     })
 
     it('should handle rapid undo/redo sequences', () => {
@@ -322,7 +321,7 @@ describe('UndoLayers', () => {
       undoLayers.redo()
       undoLayers.undo()
 
-      expect(renderFunc).toHaveBeenCalledTimes(5) // Should handle all operations
+
     })
   })
 
